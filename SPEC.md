# Babyccino: Conversational Development Tool with Visual Flowcharts

## Project Overview

Babyccino enables developers to describe software functions conversationally on an iPad, with AI generating flowcharts as visual aids and then producing production-ready code.

**Core Value Proposition:** Describe logic conversationally ‚Üí See it visualized as a flowchart ‚Üí Get production-ready, tested code

**Target User:** Hobby project developers who want to work on code architecture during mobile-only time

**MVP Scope:** Conversational interface that produces flowcharts and generates Python functions with unit tests

**Key Insight:** The flowchart is a *byproduct* of the conversation, not the primary input. Users describe what they want in natural language, AI helps refine it through conversation, and the flowchart serves as a visual representation before code generation.

---

## Architecture

### System Components

1. **iPad Native App** (Swift/SwiftUI)
   - Chat interface for conversational function description
   - Flowchart viewer (generated by AI as visual aid)
   - Server connection management
   - Code/test result viewer

2. **Python Server** (FastAPI)
   - Receives conversation messages
   - Uses Claude API to:
     - Converse with user about function requirements
     - Generate flowchart representation
     - Generate code from conversation + flowchart
   - Runs unit tests
   - Performs complexity analysis
   - Returns results to iPad

3. **Communication**
   - Local network (192.168.x.x)
   - REST API over HTTP
   - JSON payload format

### Data Flow

```
1. User describes function in chat: "I need a function that checks if a number is prime"
2. iPad sends message to server (POST /chat)
3. Server (Claude) responds with clarifying questions or refinements
4. Conversation continues until requirements are clear
5. User says "looks good" or "generate code"
6. Server generates flowchart visualization from conversation
7. iPad displays flowchart for user review
8. User confirms or requests changes
9. Server generates code based on conversation + flowchart
10. Server runs unit tests
11. Server performs complexity analysis
12. Server returns:
    - Generated code
    - Test results (pass/fail + output)
    - Complexity analysis (Big-O notation)
13. iPad displays results
```

---

## iPad App Specification

### UI Structure

#### Main Screen: Conversational Interface

**Chat Area (main content)**
- iMessage-style chat interface
- User messages (right-aligned, blue)
- AI messages (left-aligned, gray)
- Support for text messages and flowchart visualizations inline
- Auto-scroll to latest message
- Keyboard handling (shifts view when keyboard appears)

**Message Types:**
1. **Text message** - Standard chat bubble
2. **Flowchart message** - Embedded interactive flowchart view that user can pan/zoom
3. **Code result message** - Syntax-highlighted code with tabs for tests/complexity

**Input Bar (bottom)**
- Text input field with placeholder: "Describe a function you want to build..."
- Send button
- Microphone button (optional for future voice input)

**Toolbar (top)**
- "New Chat" button (starts fresh conversation)
- Server status indicator (green dot = connected)
- Settings button

**Conversation Flow:**

1. **Initial state:** 
   - Empty chat with welcome message
   - "Hi! I'm Babyccino ‚òïÔ∏è. Describe a function you'd like to build, and I'll help you design and implement it."

2. **User describes function:**
   - User: "I need a function that validates email addresses"
   - AI: "Great! Let me clarify a few things:
     - Should it check for proper format (username@domain.extension)?
     - Do you want to verify the domain exists?
     - Should it handle international characters?
     - Any specific validation rules?"

3. **Refinement conversation:**
   - Back-and-forth until requirements are clear
   - AI asks clarifying questions
   - User provides more details

4. **Flowchart generation:**
   - User: "That looks good, show me the flow"
   - AI: "Here's the logic flow for your email validator:"
   - [Flowchart appears in chat as interactive image]
   - AI: "Does this capture what you need? Reply with 'generate code' when ready, or suggest changes."

5. **Code generation:**
   - User: "generate code"
   - AI: "Generating your function with tests..."
   - [Loading indicator]
   - [Code result appears with tabs for Code/Tests/Complexity]

#### Settings Screen

- Server IP address input (default: auto-detect local IP)
- Server port input (default: 8000)
- Connection test button
- API key input (for Claude API, stored in server config)
- About/version info

### Flowchart Visualization (Read-only)

When AI generates a flowchart, it appears as an embedded view in the chat:

**Display Properties:**
- Interactive (pan/zoom with gestures)
- Read-only (user doesn't edit it directly)
- Node types visually distinct:
  - Start/End (rounded rectangle, green/red)
  - Process (rectangle, blue)
  - Decision (diamond, yellow)
  - Input/Output (parallelogram, purple)
- Arrows show flow direction
- Labels on nodes and decision branches

**Interactions:**
- Pinch to zoom
- Pan with one finger
- Tap flowchart to expand to full screen
- "Edit" button below flowchart opens conversation: "What would you like to change about this flow?"

### Conversation State Management

Each conversation has:
- `id`: UUID
- `messages`: array of Message objects
- `flowchart`: optional FlowchartData (latest generated)
- `generatedCode`: optional CodeResult (latest generated)
- `created_at`: timestamp

Message types:
- `user_text`: User's message
- `ai_text`: AI's response
- `ai_flowchart`: Flowchart visualization
- `ai_code`: Generated code with tests/complexity

### User Interactions

1. **Starting conversation:** Type description, hit send
2. **Continuing conversation:** Respond to AI questions naturally
3. **Requesting flowchart:** Say "show me the flow" or "visualize this" or "looks good"
4. **Modifying flowchart:** Describe changes in chat ("make the validation more strict")
5. **Generating code:** Say "generate code" or "build it" or "let's code it"
6. **Reviewing results:** Scroll through tabs (Code/Tests/Complexity)
7. **Iterating:** Continue conversation to refine and regenerate

### Error Handling

- No server connection: Show alert with server IP/port, offer to go to settings
- Message send failure: Show retry button
- Generation failure: AI responds with error explanation in chat
- Network timeout: AI: "That's taking longer than expected. Still working on it..."

---

## Server Specification

### Technology Stack

- **Framework:** FastAPI
- **AI Integration:** Anthropic Claude API (claude-sonnet-4-5)
- **Testing:** pytest (subprocess execution)
- **Code Analysis:** Custom complexity analyzer
- **State Management:** In-memory conversation history (dict keyed by conversation_id)

### API Endpoints

#### `POST /chat`

Conversational endpoint for discussing function requirements.

**Request Body:**
```json
{
  "conversation_id": "uuid-or-null",
  "message": "I need a function that checks if a number is prime",
  "action": "continue" // or "generate_flowchart" or "generate_code"
}
```

**Response:**
```json
{
  "conversation_id": "uuid-123",
  "message": "Great! A prime checker. Let me ask a few questions:\n\n1. Should it handle negative numbers?\n2. What should it return for 0 and 1?\n3. Do you need it optimized for large numbers?",
  "message_type": "text",
  "can_generate_flowchart": false,
  "can_generate_code": false
}
```

When conversation has enough detail:
```json
{
  "conversation_id": "uuid-123",
  "message": "Perfect! I have everything I need. Would you like to see the flowchart or go straight to code generation?",
  "message_type": "text",
  "can_generate_flowchart": true,
  "can_generate_code": true
}
```

#### `POST /generate-flowchart`

Generates flowchart from conversation history.

**Request Body:**
```json
{
  "conversation_id": "uuid-123"
}
```

**Response:**
```json
{
  "conversation_id": "uuid-123",
  "message": "Here's the logic flow for your prime checker:",
  "message_type": "flowchart",
  "flowchart": {
    "nodes": [
      {
        "id": "uuid-1",
        "type": "start",
        "label": "Start",
        "position": {"x": 100, "y": 50},
        "connections": [{"targetId": "uuid-2"}]
      },
      {
        "id": "uuid-2",
        "type": "input",
        "label": "n = input number",
        "position": {"x": 100, "y": 150},
        "connections": [{"targetId": "uuid-3"}]
      },
      {
        "id": "uuid-3",
        "type": "decision",
        "label": "n < 2?",
        "position": {"x": 100, "y": 250},
        "connections": [
          {"targetId": "uuid-4", "label": "true"},
          {"targetId": "uuid-5", "label": "false"}
        ]
      },
      {
        "id": "uuid-4",
        "type": "process",
        "label": "return False",
        "position": {"x": 50, "y": 350},
        "connections": [{"targetId": "uuid-9"}]
      },
      {
        "id": "uuid-5",
        "type": "process",
        "label": "i = 2",
        "position": {"x": 150, "y": 350},
        "connections": [{"targetId": "uuid-6"}]
      },
      {
        "id": "uuid-6",
        "type": "decision",
        "label": "i * i <= n?",
        "position": {"x": 150, "y": 450},
        "connections": [
          {"targetId": "uuid-7", "label": "true"},
          {"targetId": "uuid-8", "label": "false"}
        ]
      },
      {
        "id": "uuid-7",
        "type": "decision",
        "label": "n % i == 0?",
        "position": {"x": 100, "y": 550},
        "connections": [
          {"targetId": "uuid-4", "label": "true"},
          {"targetId": "uuid-10", "label": "false"}
        ]
      },
      {
        "id": "uuid-10",
        "type": "process",
        "label": "i = i + 1",
        "position": {"x": 150, "y": 650},
        "connections": [{"targetId": "uuid-6"}]
      },
      {
        "id": "uuid-8",
        "type": "process",
        "label": "return True",
        "position": {"x": 200, "y": 550},
        "connections": [{"targetId": "uuid-9"}]
      },
      {
        "id": "uuid-9",
        "type": "end",
        "label": "End",
        "position": {"x": 125, "y": 750},
        "connections": []
      }
    ]
  }
}
```

#### `POST /generate-code`

Generates code, tests, and complexity analysis from conversation + optional flowchart.

**Request Body:**
```json
{
  "conversation_id": "uuid-123"
}
```

**Response:**
```json
{
  "conversation_id": "uuid-123",
  "message": "Here's your prime checker function with tests:",
  "message_type": "code",
  "code": {
    "function": "def is_prime(n):\n    \"\"\"Check if a number is prime.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if prime, False otherwise\n    \"\"\"\n    if n < 2:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True",
    "tests": {
      "code": "import pytest\nfrom function import is_prime\n\ndef test_primes():\n    assert is_prime(2) == True\n    assert is_prime(3) == True\n    assert is_prime(17) == True\n\ndef test_non_primes():\n    assert is_prime(4) == False\n    assert is_prime(15) == False\n    assert is_prime(100) == False\n\ndef test_edge_cases():\n    assert is_prime(0) == False\n    assert is_prime(1) == False\n    assert is_prime(-5) == False",
      "results": [
        {"name": "test_primes", "passed": true, "output": ""},
        {"name": "test_non_primes", "passed": true, "output": ""},
        {"name": "test_edge_cases", "passed": true, "output": ""}
      ],
      "summary": "3 passed, 0 failed"
    },
    "complexity": {
      "time": "O(‚àön)",
      "space": "O(1)",
      "explanation": "Time complexity is square root of n due to loop optimization. Space complexity is constant as we only use a few variables."
    }
  }
}
```

#### `GET /health`

Health check endpoint.

**Response:**
```json
{
  "status": "ok",
  "version": "0.1.0"
}
```

### Server Logic

#### 1. Conversation Management

**System Prompt for Claude:**
```
You are Babyccino ‚òïÔ∏è, a helpful AI assistant that helps developers design and implement functions through conversation.

Your role:
1. Ask clarifying questions to fully understand the function requirements
2. Discuss edge cases, input/output types, and behavior
3. When you have enough information, let the user know you can generate a flowchart or code
4. Be conversational and friendly, but technical when needed

Guidelines:
- Ask 2-4 clarifying questions to understand the requirements
- Consider edge cases (null/empty inputs, boundaries, error conditions)
- Think about function signature (parameters, return type)
- Once requirements are clear, respond with: "I have everything I need! Would you like to see a flowchart first, or should I generate the code?"

Current conversation:
[conversation history]

User message: [user's latest message]
```

**State tracking:**
- Maintain conversation history per conversation_id
- Track when enough information is gathered (set flags: can_generate_flowchart, can_generate_code)
- Use Claude to determine when requirements are sufficiently clear

#### 2. Flowchart Generation

**Prompt for Claude:**
```
Based on this conversation about a function, generate a detailed flowchart representation.

Conversation:
[full conversation history]

Generate a JSON flowchart with nodes and connections. Use these node types:
- start: Entry point
- end: Exit point  
- input: Getting input or initializing variables
- process: Processing/computation step
- decision: Conditional branch (if/else, loops)
- output: Returning a value or producing output

Requirements:
- Include all logic branches
- Label decision nodes clearly (e.g., "x > 10?")
- Label decision connections (e.g., "true"/"false" or "yes"/"no")
- Use descriptive labels for process nodes
- Position nodes to flow top-to-bottom with appropriate spacing

Output only the JSON for the flowchart, no markdown formatting.
```

#### 3. Code Generation

**Prompt for Claude:**
```
Generate a Python function based on this conversation and optional flowchart.

Conversation:
[full conversation history]

Flowchart (if available):
[flowchart JSON]

Requirements:
- Write clean, well-documented Python code
- Include comprehensive docstring
- Follow PEP 8 style guidelines
- Handle all discussed edge cases
- Use type hints if appropriate

Output only the Python function code, no markdown formatting.
```

#### 4. Test Generation

**Prompt for Claude:**
```
Generate pytest unit tests for this function based on the conversation.

Function code:
[generated function]

Conversation context:
[relevant parts of conversation mentioning edge cases, examples]

Requirements:
- Test all discussed scenarios and edge cases
- Use clear test names (test_happy_path, test_edge_case_zero, etc.)
- Include assertions for expected behavior
- Cover positive and negative cases

Output only the test code, no markdown formatting.
```

#### 5. Test Execution

- Write generated function to temp file
- Write test code to temp file  
- Run `pytest -v` via subprocess
- Parse pytest output for pass/fail status
- Capture any error messages
- Clean up temp files

#### 6. Complexity Analysis

**Prompt for Claude:**
```
Analyze the time and space complexity of this function:

[generated function code]

Consider the algorithm's behavior:
- Loop iterations
- Recursive calls
- Data structure usage
- Memory allocation

Provide:
- Time complexity in Big-O notation
- Space complexity in Big-O notation  
- Brief explanation (2-3 sentences) of why

Output as JSON: {"time": "O(...)", "space": "O(...)", "explanation": "..."}
```

### Environment Setup

**Required:**
- Python 3.10+
- pip packages: fastapi, uvicorn, anthropic, pytest
- ANTHROPIC_API_KEY environment variable

**Configuration:**
- Server runs on 0.0.0.0:8000 (accessible on local network)
- CORS enabled for local development
- Request timeout: 90 seconds (conversation can take time)
- Max conversation history: 50 messages (to stay within context limits)

---

## Communication Protocol

### Network Discovery

- iPad app attempts connection to:
  1. User-configured IP (from settings)
  2. Auto-detected local network IPs (192.168.x.x range)
- Health check on connection to verify server is running

### Request/Response Format

- Content-Type: application/json
- Timeout: 60 seconds (code generation can take time)
- Retry logic: 3 attempts with exponential backoff

### Error Codes

- 400: Invalid flowchart data
- 500: Server error (code generation failed)
- 503: Service unavailable (Claude API error)

---

## Success Criteria for MVP

### Must Have (v0.1.0)

‚úÖ iPad app can:
- Display chat interface for function description
- Send messages to server
- Receive and display AI responses
- Display flowchart visualizations inline in chat
- Display generated code with tabs for tests/complexity
- Handle basic error cases
- Save conversation history (in-memory for session)

‚úÖ Server can:
- Maintain conversation state per conversation_id
- Converse intelligently about function requirements using Claude API
- Ask clarifying questions
- Determine when enough information is gathered
- Generate flowchart JSON from conversation
- Generate Python function from conversation + flowchart
- Generate unit tests based on discussed requirements
- Run tests and report results
- Analyze complexity
- Return all results to iPad

‚úÖ System can:
- Work over local network
- Complete conversation ‚Üí flowchart ‚Üí code flow
- Handle errors gracefully
- Complete code generation in <60 seconds

### Nice to Have (future versions)

- Persist conversation history across sessions
- Edit flowchart directly (regenerate code from edits)
- Multiple functions in one conversation/project
- Support for classes (multiple functions ‚Üí class)
- Export to GitHub
- More language targets (JS, Go, etc.)
- Voice input for describing functions
- Templates for common patterns
- Share conversations

### Non-Goals for MVP

- Authentication/authorization
- Cloud deployment
- Multi-user support
- Real-time collaboration
- Advanced flowchart editing tools
- Integration with external services
- Production deployment infrastructure

---

## Development Phases

### Phase 1: Server Foundation
- Set up FastAPI server
- Implement `/health` endpoint
- Implement `/chat` endpoint with conversation state management
- Integrate Claude API for conversational responses
- Test with curl/Postman

### Phase 2: Flowchart & Code Generation
- Implement `/generate-flowchart` endpoint
- Implement `/generate-code` endpoint
- Add test execution subprocess
- Add complexity analysis
- Test full conversation ‚Üí flowchart ‚Üí code flow

### Phase 3: iPad App Shell
- Create SwiftUI app structure
- Implement settings screen
- Implement server connection logic
- Test health check endpoint from iPad

### Phase 4: Chat Interface
- Build chat UI (message bubbles, input bar)
- Implement message sending/receiving
- Handle conversation state
- Test basic text conversation with server

### Phase 5: Visual Elements
- Implement flowchart viewer component
- Implement code result viewer with tabs
- Handle different message types in chat
- Polish UI/animations

### Phase 6: Integration & Polish
- End-to-end testing
- Error handling and edge cases
- Loading states and animations
- Performance optimization
- Bug fixes

---

## Technical Decisions & Rationale

### Why Native iOS?
- Best support for chat interfaces (native keyboard handling, gestures)
- Can leverage SwiftUI's List/ScrollView for smooth chat experience
- Native feel for visual elements (flowcharts, code viewers)
- Better performance for real-time chat interactions

### Why Python Server?
- Excellent AI library support (anthropic SDK)
- Easy subprocess management for running tests
- FastAPI is simple, fast, and has great async support for chat

### Why Conversational-First?
- More natural for developers to describe logic in plain language
- Reduces friction compared to drawing flowcharts directly
- AI can ask clarifying questions that humans might forget
- Flowchart becomes a confirmation/visualization tool, not primary input
- Better mobile experience (typing > complex touch gestures for diagramming)

### Why Local Network?
- No cloud infrastructure needed for MVP
- Lower latency for chat responsiveness
- Privacy (code never leaves local network)
- Can deploy server to cloud later if needed

### Why Claude API?
- Excellent conversational abilities (natural clarifying questions)
- Strong at structured outputs (flowchart JSON)
- Best-in-class code generation
- Reliable for complexity analysis

### Why Separate Endpoints for Flowchart/Code?
- Gives user control over workflow (see flowchart first, or skip to code)
- Allows iteration on flowchart without regenerating code
- Clearer separation of concerns
- Better error handling for each stage

---

## Open Questions / Decisions Needed

1. **Conversation persistence:** Should conversations persist across app restarts?
   - **Suggestion:** In-memory for MVP, add persistence in v2

2. **Flowchart editing:** If user wants to change flowchart, do they edit visually or describe changes in chat?
   - **Suggestion:** Chat-based for MVP (keeps it simple), visual editing in v2

3. **Multiple functions:** Can one conversation generate multiple related functions?
   - **Suggestion:** Single function per conversation for MVP

4. **Code iteration:** If tests fail, how does user request fixes?
   - **Suggestion:** Continue conversation ("The tests failed, can you fix the edge case for negative numbers?")

5. **Conversation limits:** Max messages before requiring new conversation?
   - **Suggestion:** 50 messages (stays within Claude context window)

6. **Function naming:** Who decides function name - user or Claude?
   - **Suggestion:** Claude suggests during conversation, user can override

---

## Getting Started

### For Claude Code:

This spec defines a two-part system:
1. iOS/iPad app (Swift/SwiftUI) with conversational chat interface
2. Python server (FastAPI) for AI-powered conversation, flowchart generation, and code generation

Start with **Phase 1** (Server Foundation) as it has no UI dependencies and can be tested independently with curl/Postman.

Initial server directory structure:
```
babyccino-server/
‚îú‚îÄ‚îÄ main.py                  # FastAPI app and endpoints
‚îú‚îÄ‚îÄ models.py                # Pydantic models for request/response
‚îú‚îÄ‚îÄ conversation.py          # Conversation state management
‚îú‚îÄ‚îÄ generator.py             # Claude API integration (chat, flowchart, code)
‚îú‚îÄ‚îÄ test_runner.py           # Test execution and parsing
‚îú‚îÄ‚îÄ complexity.py            # Complexity analysis
‚îú‚îÄ‚îÄ requirements.txt         # Dependencies
‚îî‚îÄ‚îÄ .env.example             # ANTHROPIC_API_KEY placeholder
```

Initial iOS app directory structure:
```
Babyccino/
‚îú‚îÄ‚îÄ Babyccino.xcodeproj
‚îú‚îÄ‚îÄ Babyccino/
‚îÇ   ‚îú‚îÄ‚îÄ BabyccinoApp.swift           # App entry point
‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChatView.swift           # Main chat interface
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MessageBubbleView.swift  # Individual message display
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FlowchartView.swift      # Flowchart visualization
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CodeResultView.swift     # Code with tabs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SettingsView.swift       # Server settings
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Message.swift            # Chat message model
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Conversation.swift       # Conversation state
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FlowchartData.swift      # Flowchart structure
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CodeResult.swift         # Generated code result
‚îÇ   ‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ServerClient.swift       # API client
‚îÇ   ‚îî‚îÄ‚îÄ Assets.xcassets
```

### Example Server Test (curl)

```bash
# Start conversation
curl -X POST http://192.168.1.100:8000/chat \
  -H "Content-Type: application/json" \
  -d '{
    "conversation_id": null,
    "message": "I need a function that checks if a string is a palindrome",
    "action": "continue"
  }'

# Continue conversation
curl -X POST http://192.168.1.100:8000/chat \
  -H "Content-Type: application/json" \
  -d '{
    "conversation_id": "uuid-from-previous-response",
    "message": "Ignore case and spaces",
    "action": "continue"
  }'

# Generate flowchart
curl -X POST http://192.168.1.100:8000/generate-flowchart \
  -H "Content-Type: application/json" \
  -d '{
    "conversation_id": "uuid-from-previous-response"
  }'

# Generate code
curl -X POST http://192.168.1.100:8000/generate-code \
  -H "Content-Type: application/json" \
  -d '{
    "conversation_id": "uuid-from-previous-response"
  }'
```

Ready to build! üöÄ
